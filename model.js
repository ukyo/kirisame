// Generated by CoffeeScript 1.4.0
(function() {
  var EntrySchema, config, db, defineStaticMethods, generateMongoUrl, moment, mongoSetting, mongoose;

  mongoose = require('mongoose');

  moment = require('moment');

  config = require('./config');

  mongoSetting = {
    hostname: 'localhost',
    port: 27017,
    username: '',
    password: '',
    name: '',
    db: 'db'
  };

  if (process.env.VCAP_SERVICES) {
    mongoSetting = JSON.parse(process.env.VCAP_SERVICES)['mongodb-2.0'][0]['credentials'];
  }

  generateMongoUrl = function(o) {
    var _ref, _ref1, _ref2;
    if ((_ref = o.hostname) == null) {
      o.hostname = 'localhost';
    }
    if ((_ref1 = o.port) == null) {
      o.port = 27017;
    }
    if ((_ref2 = o.db) == null) {
      o.db = 'test';
    }
    if (o.username && o.password) {
      return "mongodb://" + o.username + ":" + o.password + "@" + o.hostname + ":" + o.port + "/" + o.db;
    } else {
      return "mongodb://" + o.hostname + ":" + o.port + "/" + o.db;
    }
  };

  EntrySchema = mongoose.Schema({
    name: {
      type: String,
      required: true,
      unique: true
    },
    title: {
      type: String,
      required: true
    },
    _tags: {
      type: Array
    },
    text: {
      type: String,
      required: true
    },
    html: {
      type: String,
      required: true
    },
    created: {
      type: Date,
      "default": Date.now
    }
  });

  EntrySchema.pre('save', function(next) {
    this.text = this.text.replace(/\r\n|\r/g, '\n');
    return next();
  });

  EntrySchema.virtual('tags').set(function(tags) {
    return this._tags = tags.split(/,\s*/g);
  });

  EntrySchema.virtual('tags').get(function() {
    return this._tags;
  });

  EntrySchema.virtual('tagsForEditor').get(function() {
    return this._tags.join(', ');
  });

  EntrySchema.virtual('textForEditor').get(function() {
    return this.text.replace(/&/g, '&amp;');
  });

  EntrySchema.virtual('createdForWeb').get(function() {
    return moment(this.created).format('MMMM Do YYYY');
  });

  defineStaticMethods = function() {
    var cache;
    cache = {
      dict: {},
      get: function(key) {
        return this.dict[key];
      },
      set: function(key, value) {
        return this.dict[key] = value;
      },
      remove: function(key) {
        return this.dict[key] = null;
      },
      clear: function() {
        return this.dict = {};
      }
    };
    this.findByName = function(name, callback) {
      var entry;
      entry = cache.get(name);
      if (entry) {
        return callback.call(this, null, entry);
      }
      return this.findOne({
        name: name
      }, function(err, entry) {
        if (err) {
          return callback.call(this, err);
        }
        cache.set(name, entry);
        return callback.call(this, err, entry);
      });
    };
    this.findByNameAndUpdate = function(name, obj, callback) {
      var pullTags, pushTags, updateOther,
        _this = this;
      pullTags = function() {
        return _this.update({
          name: name
        }, {
          $pullAll: {
            _tags: obj.oldTags.split(/,\s*/g)
          }
        }, function(err) {
          if (err) {
            return callback.call(this, err);
          }
          return pushTags();
        });
      };
      pushTags = function() {
        return _this.update({
          name: name
        }, {
          $pushAll: {
            _tags: obj.tags.split(/,\s*/g)
          }
        }, function(err) {
          if (err) {
            return callback.call(this, err);
          }
          return updateOther();
        });
      };
      updateOther = function() {
        return _this.update({
          name: name
        }, obj, function(err) {
          if (err) {
            return callback.call(this, err);
          }
          cache.clear();
          return callback.call(this, err);
        });
      };
      return pullTags();
    };
    this.findByNameAndRemove = function(name, callback) {
      return this.findOneAndRemove({
        name: name
      }, function(err) {
        if (err) {
          return callback.call(this, err);
        }
        cache.clear();
        return callback.call(this, err);
      });
    };
    this.findByPage = function(obj, callback) {
      var context, filter, key, len, page;
      key = JSON.stringify(obj);
      context = cache.get(key);
      if (context) {
        return callback.call(this, null, context.entries, context);
      }
      filter = obj.filter || {};
      page = obj.page || 1;
      len = obj.length;
      return this.find(filter).sort({
        created: -1
      }).skip((page - 1) * len).limit(len + 1).exec(function(err, entries) {
        if (err) {
          return callback.call(this, err);
        }
        context = {
          next: (entries.length > len ? page + 1 : void 0),
          prev: page > 1 ? page - 1 : void 0,
          entries: entries.slice(0, len)
        };
        cache.set(key, context);
        return callback.call(this, null, entries, context);
      });
    };
    this.getTagCloud = function(callback) {
      var obj, tagCloud;
      tagCloud = cache.get('__tagCloud__');
      if (tagCloud) {
        return callback.call(this, null, tagCloud);
      }
      obj = {
        map: function() {
          var tag, _i, _len, _ref, _results;
          _ref = this._tags;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            tag = _ref[_i];
            _results.push(emit(tag, 1));
          }
          return _results;
        },
        reduce: function(k, values) {
          return values.length;
        }
      };
      return this.mapReduce(obj, function(err, results) {
        if (err) {
          return callback.call(this, err);
        }
        cache.set('__tagCloud__', results);
        return callback.call(this, err, results);
      });
    };
    this.getTagEntries = function(page, tag, callback) {
      var obj;
      obj = {
        filter: {
          _tags: {
            $in: [tag]
          }
        },
        page: page,
        length: config.indexEntryLength
      };
      return this.findByPage(obj, callback);
    };
    this.getIndexEntries = function(page, callback) {
      return this.findByPage({
        page: page,
        length: config.indexEntryLength
      }, callback);
    };
    this.getAdminEntries = function(page, callback) {
      return this.findByPage({
        page: page,
        length: config.recentEntryLength
      }, callback);
    };
    return this.getRecentEntries = function(callback) {
      return this.findByPage({
        length: config.recentEntryLength
      }, callback);
    };
  };

  defineStaticMethods.call(EntrySchema.statics);

  db = mongoose.createConnection(generateMongoUrl(mongoSetting));

  module.exports.Entry = db.model('Entry', EntrySchema);

}).call(this);
